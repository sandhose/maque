#!/bin/sh

# Default options
OPTS_MAKEFILE="`find . -name [Mm]akefile -maxdepth 1`"
OPTS_DRYRUN=false
OPTS_KEEPGOING=false
OPTS_TARGETS=""

DEBUG=false

# Show usage
usage () {
    cat <<EOL
Usage: `basename $0` [-f makefile] [-hkn] [target]
Options:
    -f FILE       Read FILE as a makefile
    -h            Print this message and exit.
    -k            Keep going when some targets can't be made.
    -n            Don't actually run any commands; just print them
EOL
}

# Create tempdir
init_tmpdir () {
    # Uses TMPDIR (fallback: /tmp)
    # ex: /tmp/maque-1234
    TDIR=${TMPDIR:-/tmp/}$(basename $0)-$$
    mkdir -p $TDIR
    trap "rm -r $TDIR" EXIT
}

# Parse commandline options
parse_commandline () {
    args=`getopt "f:hkn" $*`

    if [ $? != 0 ]; then
        usage >&2
        exit 2
    fi

    set -- $args
    for i; do
        case "$i" in
            -h) usage
                exit 0
                shift;;
            -f) OPTS_MAKEFILE=$2
                shift 2;;
            -k) OPTS_KEEPGOING=true
                shift;;
            -n) OPTS_DRYRUN=true
                shift;;
            --) shift
                break;;
        esac
    done

    # Testing makefile existence
    if [ ! -f $OPTS_MAKEFILE ] || [ -z $OPTS_MAKEFILE ]; then
        echo "$(basename $0): *** Makefile not found.  Stop." >&2
        exit 2
    fi

    OPTS_TARGETS=$*
}

# Parse makefile
parse_makefile () {
    local CURRENT_TARGET=""
    local DEFAULT_TARGET=""
    local LINE_NB=0
    local LINE

    # Keep leading spaces/tabs in `read`
    local OLDIFS=$IFS
    IFS=''

    while read RAW_LINE; do
        LINE=`echo $RAW_LINE | sed -e 's/#.*$//g' -e 's/[[:space:]]*$//'`
        LINE_NB=$((LINE_NB + 1))
        if [ -z $LINE ]; then
            # Empty line, do nothing
            continue
        elif [ ! -z $CURRENT_TARGET ] && (echo "$LINE" | grep -q ^'\t'); then
            # Append commands to $CURRENT_TARGET commands file
            echo "$LINE" | sed 's/^[[:space:]]*\(.*\)$/\1/' >> $TDIR/$CURRENT_TARGET/commands
        elif (echo "$LINE" | grep -q '^.\+:\( .\+\)*$'); then
            # Change $CURRENT_TARGET and add dependencies in file
            CURRENT_TARGET=`echo $LINE | cut -d ':' -f 1`
            mkdir -p $TDIR/$CURRENT_TARGET
            touch $TDIR/$CURRENT_TARGET/commands
            echo "$LINE" | sed 's/^.*: *//g' > $TDIR/$CURRENT_TARGET/dependencies

            if [ -z $DEFAULT_TARGET ]; then
                DEFAULT_TARGET=$CURRENT_TARGET
            fi
        else
            echo "$1:$LINE_NB: *** Error parsing makefile.  Stop." >&2
            exit 2
        fi
    done < $1

    # Restore IFS
    IFS=$OLDIFS

    # Set default target if no target specified
    if [ -z "$OPTS_TARGETS" ]; then
        OPTS_TARGETS=$DEFAULT_TARGET
    fi
}

INDENT=""

# @returns: 0 = nothing done ; 1 = target just built ; 2 = error
build_target_if_needed () {
    local TARGET=$1
    local NEED_BUILD=false
    local WAS_DEPS_BUILT
    local NEWER_DEPS
    local FIND_EXPR

    if [ -d $TDIR/$TARGET ]; then
        # Debugging
        $DEBUG && echo "${INDENT}Building target \`$TARGET'"
        INDENT=$INDENT"  "

        if ! [ -f $TARGET ]; then
            $DEBUG && echo "${INDENT} --> file inexistant"
            NEED_BUILD=true
        fi

        if [ -s $TDIR/$TARGET/dependencies ]; then
            DEPS=`cat $TDIR/$TARGET/dependencies`
            build_targets $DEPS
            case $? in
                1) NEED_BUILD=true;;
                2) INDENT=`echo "$INDENT" | cut -c 3-`
                    return 2;; # Deps build failed
            esac

            if ! $NEED_BUILD; then # Target already built ; check if update needed
                NEWER_DEPS=$(find $DEPS -newer $TARGET)
                if [ -n "$NEWER_DEPS" ]; then
                    $DEBUG && echo "${INDENT} --> Newer files"
                    NEED_BUILD=true
                fi
            fi
        fi

        INDENT=`echo "$INDENT" | cut -c 3-`

        if $NEED_BUILD; then
            $DEBUG && echo "${INDENT}Need to build $TARGET"
            return 1 # We actually did something!
        else
            $DEBUG && echo "${INDENT}Target \`$TARGET' already up to date"
            return 0 # Already up to date
        fi

        return 1 # Target was built
    elif ! [ -f $TARGET ]; then
        if ! [ -z $PARENT_TARGET ]; then
            echo "`basename $0`: *** No rule to make target \`$TARGET', needed by \`$PARENT_TARGET'.  Stop." >&2
        else
            echo "`basename $0`: *** No rule to make target \`$TARGET'.  Stop." >&2
        fi
        return 2
    else
        return 0 # Can't build but file exists
    fi
}

build_targets () {
    local PARENT_TARGET=$TARGET # Expose parent target
    local TARGET
    local WAS_BUILT=0
    for TARGET; do
        build_target_if_needed $TARGET
        case $? in
            1) WAS_BUILT=1;;
            2) return 2;; # Target errored
        esac
    done

    return $WAS_BUILT
}

# Run everything
init_tmpdir
parse_commandline $*
parse_makefile "$OPTS_MAKEFILE"
build_targets $OPTS_TARGETS

# vim: ts=4:sw=4:et
